// SPDX-License-Identifier: LGPL-3.0-or-later
pragma solidity ^0.7.6;
pragma abicoder v2;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";

import {GPv2Order} from "@cow-protocol/contracts/libraries/GPv2Order.sol";

import {IGPv2Settlement} from "../interfaces/IGPv2Settlement.sol";
import {IPriceChecker} from "../interfaces/IPriceChecker.sol";

/// @title Milkman
/// @notice Trustlessly execute swaps through the CoW Protocol.
/// @dev Design documentation on HackMD: https://hackmd.io/XIOWY5VPRuqBO_74Aef61w?view. Use with atypical tokens (e.g., rebasing tokens) not recommended.
contract Milkman {
    using SafeERC20 for IERC20;
    using GPv2Order for GPv2Order.Data;
    using GPv2Order for bytes;
    using SafeMath for uint256;

    event SwapRequested(
        bytes32 swapID,
        address user,
        address receiver,
        IERC20 fromToken,
        IERC20 toToken,
        uint256 amountIn,
        address priceChecker,
        uint256 nonce
    );
    // swapID is generated by Milkman, orderUID is generated by CoW Protocol
    event SwapPaired(bytes32 swapID, bytes orderUID, uint256 blockNumber);
    event SwapUnpaired(bytes32 swapID);
    event SwapExecuted(bytes32 swapID);
    event SwapCancelled(bytes32 swapID);

    // global nonce that is incremented after every swap request
    uint256 public nonce;
    // map swap ID => empty if not active, bytes(1) if requested but not paired, and packed blockNumber,orderUID if paired
    mapping(bytes32 => bytes) public swaps;

    // Who we give allowance
    address internal constant gnosisVaultRelayer =
        0xC92E8bdf79f0507f65a392b0ab4667716BFE0110;
    // Where we pre-sign
    IGPv2Settlement internal constant settlement =
        IGPv2Settlement(0x9008D19f58AAbD9eD0D60971565AA8510560ab41);
    // Settlement's domain separator, used to hash order IDs
    bytes32 internal constant domainSeparator =
        0xc078f884a2676e1345748b1feace7b0abee5d00ecadb6e574dcdd109a63e8943;

    bytes32 internal constant KIND_SELL =
        hex"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775";

    bytes32 internal constant BALANCE_ERC20 =
        hex"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9";

    // The byte length of an order unique identifier.
    uint256 internal constant UID_LENGTH = 56;

    /// @notice Swap an exact amount of tokens for a market-determined amount of other tokens.
    /// @dev Stores a hash of this swap in storage, putting it in requested state.
    /// @param _amountIn The number of tokens to sell.
    /// @param _fromToken The token that the user wishes to sell.
    /// @param _toToken The token that the user wishes to buy.
    /// @param _to Who should receive the bought tokens.
    /// @param _priceChecker An optional contract (use address(0) for none) that checks, on behalf of the user, that the CoW protocol order that Milkman signs has set a reasonable minOut.
    function requestSwapExactTokensForTokens(
        uint256 _amountIn,
        IERC20 _fromToken,
        IERC20 _toToken,
        address _to,
        address _priceChecker
    ) external {
        _fromToken.safeTransferFrom(msg.sender, address(this), _amountIn);

        // Assumption: relayer allowance always either 0 or so high that it will never need to be set again
        if (_fromToken.allowance(address(this), gnosisVaultRelayer) == 0) {
            _fromToken.safeApprove(gnosisVaultRelayer, type(uint256).max);
        }

        uint256 _nonce = nonce;
        nonce += 1;

        bytes32 _swapID = keccak256(
            abi.encode(
                msg.sender,
                _to,
                _fromToken,
                _toToken,
                _amountIn,
                _priceChecker,
                _nonce
            )
        );

        swaps[_swapID] = abi.encode(1);

        emit SwapRequested(
            _swapID,
            msg.sender,
            _to,
            _fromToken,
            _toToken,
            _amountIn,
            _priceChecker,
            _nonce
        );
    }

    /// @notice Pair a requested swap against a CoW Protocol order that was generated via the API.
    /// @dev After the order passes a host of checks, milkman signs it via the 'setPreSignature' function.
    /// @param _order CoW Protocol order.
    /// @param _user The account that requested this swap.
    /// @param _priceChecker The priceChecker that the user input in their swap request.
    /// @param _nonce The nonce of the swap request.
    function pairSwap(
        GPv2Order.Data calldata _order,
        address _user,
        address _priceChecker,
        uint256 _nonce
    ) external {
        bytes32 _orderDigest = _order.hash(domainSeparator);

        bytes memory _orderUid = new bytes(UID_LENGTH);

        _orderUid.packOrderUidParams(
            _orderDigest,
            address(this),
            _order.validTo
        );

        bytes32 _swapID = keccak256(
            abi.encode(
                _user,
                _order.receiver,
                _order.sellToken,
                _order.buyToken,
                _order.sellAmount.add(_order.feeAmount),
                _priceChecker,
                _nonce
            )
        );

        bytes memory _swapData = swaps[_swapID];
        require(
            _swapData.length == 32 && _swapData[31] == bytes1(uint8(1)),
            "!swap_requested"
        );

        require(_order.kind == KIND_SELL, "!kind_sell");

        require(
            _order.validTo >= block.timestamp + 5 minutes,
            "expires_too_soon"
        );

        require(!_order.partiallyFillable, "!fill_or_kill");

        require(_order.sellTokenBalance == BALANCE_ERC20, "!sell_erc20");

        require(_order.buyTokenBalance == BALANCE_ERC20, "!buy_erc20");

        require(settlement.filledAmount(_orderUid) == 0, "!unique");

        // putting this before the priceChecker call prevents re-entrancy
        swaps[_swapID] = abi.encode(block.number, _orderUid);

        if (_priceChecker != address(0)) {
            require(
                IPriceChecker(_priceChecker).checkPrice(
                    _order.sellAmount.add(_order.feeAmount),
                    address(_order.sellToken),
                    address(_order.buyToken),
                    _order.buyAmount
                ),
                "invalid_min_out"
            );
        }

        settlement.setPreSignature(_orderUid, true);

        emit SwapPaired(_swapID, _orderUid, block.number);
    }

    /// @notice Unpair a swap by proving that it hasn't been executed within the alloted 50 blocks.
    /// @param _swapID The ID of this swap request, generated by hashing its parameters with a nonce.
    function unpairSwap(bytes32 _swapID) external {
        (uint256 _blockNumberWhenPaired, bytes memory _orderUid) = abi.decode(
            swaps[_swapID],
            (uint256, bytes)
        );

        require(
            block.number >= _blockNumberWhenPaired + 50 &&
                settlement.filledAmount(_orderUid) == 0 &&
                _blockNumberWhenPaired != 0, // last check to ensure that the swap exists at all
            "!unpairable"
        );

        settlement.setPreSignature(_orderUid, false);

        swaps[_swapID] = abi.encode(1);

        emit SwapUnpaired(_swapID);
    }

    /// @notice Prove that a paired swap has been executed (reverts if it hasn't).
    /// @dev This serves no standalone purpose other than deleting storage, but it could be used by a wrapper keep3r contract.
    /// @param _swapID The ID of this swap request, generated by hashing its parameters with a nonce.
    function proveExecuted(bytes32 _swapID) external {
        (, bytes memory _orderUid) = abi.decode(
            swaps[_swapID],
            (uint256, bytes)
        );

        require(settlement.filledAmount(_orderUid) != 0, "!executed");

        delete swaps[_swapID];

        emit SwapExecuted(_swapID);
    }

    /// @notice Cancel a requested swap, returning funds to the user.
    /// @dev This is useful if for some reason the swap can't be processed by CoW Protocol, e.g., if there's no market for either the _fromToken or the _toToken.
    /// @param _amountIn _amountIn passed in the swap request.
    /// @param _fromToken _fromToken passed in the swap request.
    /// @param _toToken _toToken passed in the swap request.
    /// @param _to _to passed in the swap request.
    /// @param _priceChecker _priceChecker passed in the swap request.
    /// @param _nonce _nonce of this swap request.
    function cancelSwapRequest(
        uint256 _amountIn,
        IERC20 _fromToken,
        IERC20 _toToken,
        address _to,
        address _priceChecker,
        uint256 _nonce
    ) external {
        bytes32 _swapID = keccak256(
            abi.encode(
                msg.sender,
                _to,
                _fromToken,
                _toToken,
                _amountIn,
                _priceChecker,
                _nonce
            )
        );

        bytes memory _swapData = swaps[_swapID];
        require(
            _swapData.length == 32 && _swapData[31] == bytes1(uint8(1)),
            "!swap_requested"
        );

        delete swaps[_swapID];

        _fromToken.safeTransfer(msg.sender, _amountIn);

        emit SwapCancelled(_swapID);
    }
}
